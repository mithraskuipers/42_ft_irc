/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   splash.cpp                                         :+:    :+:            */
/*                                                     +:+                    */
/*   By: mkuipers <mkuipers@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/09/01 17:37:03 by mkuipers      #+#    #+#                 */
/*   Updated: 2023/09/01 17:50:34 by mkuipers      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/includes.hpp"

void	color_red()
{
	printf("\033[0;31m");
}

void	color_orange()
{
	printf("\033[38;5;214m");
}

void	color_green()
{
	printf("\033[0;32m");
}

void	color_reset()
{
	printf("\033[0m");
}

void	clear_screen(void)
{
	write(1, "\x1b[2J", 4);
	write(1, "\x1b[H", 3);
}

void	splash()
{
	clear_screen();
	color_orange();
	printf("%s", SPLASH);
	color_reset();
}#include "IRCServer.hpp"
#include <unistd.h>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <sys/types.h>
#include <netdb.h>		 // Add this line to include the netdb.h header
#include "IRCServer.hpp" // Include your IRCServer.hpp file after the necessary system

IRCServer::IRCServer() : port(1234), password("")
{
	this->active_users = 0;
	this->getHostIP();
}

IRCServer::IRCServer(int port, const std::string &password) : port(port), password(password)
{
	this->active_users = 0;
	this->getHostIP();
}

IRCServer::~IRCServer()
{
	// Destructor logic if needed
}

void IRCServer::getHostIP()
{
	char host[256];
	gethostname(host, sizeof(host));

	struct hostent *host_entry;
	host_entry = gethostbyname(host);

	this->IP = inet_ntoa(*((struct in_addr *)host_entry->h_addr_list[0]));
}

void IRCServer::initServer()
{
	int opt = 1;
	this->server_listening_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (this->server_listening_socket == 0)
	{
		throw std::runtime_error("Failed to create socket");
	}

	int setsockopt_ret = setsockopt(server_listening_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	if (setsockopt_ret == -1)
	{
		throw std::runtime_error("Failed to set socket options");
	}

	this->socket_address.sin_family = AF_INET;
	this->socket_address.sin_addr.s_addr = INADDR_ANY;
	this->socket_address.sin_port = htons(port);

	if (fcntl(server_listening_socket, F_SETFL, O_NONBLOCK) < -1)
	{
		throw std::runtime_error("Failed to set non-blocking mode");
	}

	if (bind(server_listening_socket, (struct sockaddr *)&this->socket_address, sizeof(this->socket_address)) < 0)
	{
		throw std::runtime_error("Failed to bind socket");
	}

	if (listen(server_listening_socket, QUEUE_SIZE) == -1)
	{
		throw std::runtime_error("Failed to start listening");
	}

	std::cout << "Listening on port: " << this->port << std::endl;
	std::cout << "The password you chose to use is: " << this->password << std::endl;
}

#include <cstdlib>
#include <ctime>

std::string IRCServer::generateRandomCode()
{
	std::string randomCode;
	srand(time(0)); // Seed for random number generation based on current time

	// Generate a random code with a length of 4 digits
	for (int i = 0; i < 4; ++i)
	{
		char randomDigit = '0' + rand() % 10; // Generate a random digit
		randomCode.push_back(randomDigit);
	}

	return randomCode;
}

bool IRCServer::isNicknameInUse(const std::string &nickname) const
{
	for (const auto &User : clients)
	{
		if (User.getNick() == nickname)
		{
			return true;
		}
	}
	return false;
}

int IRCServer::updateMaxSocketDescriptor()
{
	int maxSocket = server_listening_socket;

	for (const auto &User : clients)
	{
		if (User.getSocketDescriptor() > maxSocket)
		{
			maxSocket = User.getSocketDescriptor();
		}
	}
	return maxSocket;
}

std::string IRCServer::addClientSocket(int clientSocket) // Update the definition
{
	std::string defaultNickname = "Guest";
	std::string randomCode;

	// Generate a random number code and check if it's not already in use
	do
	{
		randomCode = generateRandomCode();
	} while (isNicknameInUse(defaultNickname + randomCode));

	defaultNickname = defaultNickname + randomCode;
	clients.push_back(User(clientSocket, defaultNickname));

	return defaultNickname; // Return the generated username
}

void IRCServer::start()
{
	std::vector<char> buffer(2048);

	while (true)
	{
		fd_set fd_pack;
		FD_ZERO(&fd_pack);
		FD_SET(server_listening_socket, &fd_pack);

		int max_socket_fd = updateMaxSocketDescriptor();

		for (const auto &User : clients)
		{
			FD_SET(User.getSocketDescriptor(), &fd_pack);
		}

		int readySockets = select(max_socket_fd + 1, &fd_pack, NULL, NULL, NULL);

		if (readySockets == -1)
		{
			perror("select");
			break;
		}

        if (FD_ISSET(server_listening_socket, &fd_pack))
        {
            int socket_descriptor = accept(server_listening_socket, NULL, NULL);

            if (socket_descriptor == -1)
            {
                perror("accept");
                continue;
            }
            else
            {
                std::string username = addClientSocket(socket_descriptor);
                std::cout << "New User connected. Total clients: " << clients.size() << std::endl;

                // Send IRC welcome messages to the client
                std::string welcomeMessage = ":randomservernaam 001 " + username + " :Welcome to the IRC server, " + username + "!\r\n";
                send(socket_descriptor, welcomeMessage.c_str(), welcomeMessage.size(), 0);

                // Send MOTD (Message of the Day) message to the client
                std::string motdMessage = ":randomservernaam 375 " + username + " :- randomservernaam Message of the Day -\r\n";
                send(socket_descriptor, motdMessage.c_str(), motdMessage.size(), 0);

                // Send MOTD content to the client (customize this according to your server's MOTD)
                std::string motdContent = ":randomservernaam 372 " + username + " :- Welcome to our IRC server! Enjoy your stay.\r\n";
                send(socket_descriptor, motdContent.c_str(), motdContent.size(), 0);

                // Send end of MOTD message
                std::string endMotdMessage = ":randomservernaam 376 " + username + " :End of /MOTD command.\r\n";
                send(socket_descriptor, endMotdMessage.c_str(), endMotdMessage.size(), 0);
            }
        }

		// Inside your while loop where you handle incoming data and disconnections
		for (auto it = clients.begin(); it != clients.end();)
		{
			int socket_descriptor = it->getSocketDescriptor();
			if (FD_ISSET(socket_descriptor, &fd_pack))
			{
				int bytes_received = recv(socket_descriptor, buffer.data(), buffer.size(), 0);

				if (bytes_received <= 0)
				{
					if (bytes_received == 0)
					{
						std::cout << "Client disconnected. Total clients: " << clients.size() - 1 << std::endl;
					}
					else
					{
						perror("recv");
					}
					close(socket_descriptor);
					it = clients.erase(it); // Remove the client from the list
					continue;
				}

				std::string received_data(buffer.data(), bytes_received);
				if (received_data.size() > 1024)
				{
					close(socket_descriptor);
					it = clients.erase(it);
					continue;
				}
				it->getBuff().append(received_data);

				while (it->getBuff().find('\n') != std::string::npos)
				{
					std::string complete_command = it->getBuff().substr(0, it->getBuff().find('\n') + 1);

					// Remove leading newline characters
					size_t first_non_newline = complete_command.find_first_not_of("\n");
					if (first_non_newline != std::string::npos)
					{
						complete_command = complete_command.substr(first_non_newline);
					}

					// Remove trailing newline characters
					size_t last_non_newline = complete_command.find_last_not_of("\n");
					if (last_non_newline != std::string::npos)
					{
						complete_command = complete_command.substr(0, last_non_newline + 1);
					}

					std::cout << "Command received, socket fd : " << socket_descriptor << ", IP : " << it->getIP() << ", port : " << it->getPort() << std::endl;
					command.process(complete_command, *it, channels);
					
					it->getBuff().erase(0, complete_command.length());
				}
			}
			it++;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   User.cpp                                         :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/17 22:22:03 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/18 23:01:05 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/User.hpp"

#include <arpa/inet.h>	// For inet_ntop
#include <netinet/in.h> // For sockaddr_in
#include <sys/socket.h> // For getpeername
#include <unistd.h>		// For close function

// Constructor
#include "./../incs/User.hpp"
// Other necessary includes

User::User(int socket_descriptor, const std::string &nick) : socket_descriptor(socket_descriptor), port(0), _nickname(nick), registered(false), ip("Unknown IP")
{
	// Constructor implementation
}

// Getter function for the socket descriptor
int User::getSocketDescriptor() const
{
	return (socket_descriptor);
}

// Getter function for the buffer
std::string &User::getBuff()
{
	return (buff);
}

void User::setNick(const std::string &newNick)
{
	_nickname = newNick;
}

void User::setRealName(const std::string &newRealName)
{
	_realname = newRealName;
}

void User::send(const std::string &data)
{
	ssize_t bytesSent = write(socket_descriptor, data.c_str(), data.size());

	if (bytesSent < 0)
	{
		// Handle write error
	}
}

void User::sendToClient(const std::string &data)
{
	ssize_t bytesSent = ::send(socket_descriptor, data.c_str(), data.size(), 0);
	if (bytesSent == -1)
	{
		// Handle error, e.g., print an error message or close the connection
	}
}

// Getter function for the User's IP address
std::string User::getIP() const
{
	struct sockaddr_in addr;
	socklen_t addr_len = sizeof(addr);
	char ip[INET_ADDRSTRLEN];

	if (getpeername(socket_descriptor, (struct sockaddr *)&addr, &addr_len) == 0)
	{
		inet_ntop(AF_INET, &(addr.sin_addr), ip, INET_ADDRSTRLEN);
		return ip;
	}
	else
	{
		return ("Unknown IP");
	}
}

bool User::getRegisteredStatus() const
{
	return registered;
}

// Setter function to set the User's IP address
void User::setIP(const std::string &clientIP)
{
	ip = (clientIP);
}

// Getter function for the User's port
int User::getPort() const
{
	return (port);
}

// Setter function to set the User's port
void User::setPort(int clientPort)
{
	this->port = clientPort;
}

// Getter function for the User's nickname
std::string User::getNick() const
{
	return (_nickname);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   ft_split.cpp                                       :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/18 23:43:16 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/20 11:10:43 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/includes.hpp"

std::vector<std::string> ft_split(const std::string& input, const std::string& delimiter)
{
	std::vector<std::string> tokens;
	std::size_t start = 0;
	std::size_t end = input.find(delimiter);

	while (end != std::string::npos)
	{
		tokens.push_back(input.substr(start, end - start));
		start = end + delimiter.length();
		end = input.find(delimiter, start);
	}

	tokens.push_back(input.substr(start));

	return tokens;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   main.cpp                                           :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/07/08 14:09:49 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/21 22:55:39 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/includes.hpp"
#include "./../incs/splash.hpp"

int err_msg_and_return(std::string s, int ret_val)
{
	std::cout << s << std::endl;
	return (ret_val);
}

int	main(int argc, char **argv)
{
	splash();
	if (argc != 3)
		return (err_msg_and_return("Error: Usage: ./ircserv <port #> <password>", 1));
	int port = atoi(argv[1]);

	if (port < 1024 || port > 65535)											// Ports below 1024 are reserved

		return (err_msg_and_return("Error: <port #> must be an int >= 1024 and =< 65535", 1));

	IRCServer server(port, argv[2]);
	try
	{
		server.initServer();
		server.start();
	}
	catch(const std::exception& e)
	{
		std::cerr << e.what() << '\n';
	}
	return (0);
}

/*
Uitleg verbinden met Pidgin:


[STAP 1: VIA PIDGIN 1E CLIENT VERBINDEN]
Zet de server aan met port "6667" (standaard IRC protocol port) en password "pw"
./irc 6667 pw
Ga naar Pidgin:
[BASIC] -> Protocol: IRC
[BASIC] -> Username: <WHATEVER>
[BASIC] -> Server: 127.0.0.1
[BASIC] -> Password: pw
[BASIC] -> Local alias: <LEEG>
[ADVANCED] -> Port: 6667


*/

/*
Server Socket:
This is the socket used by the server program to listen for incoming connections from clients.
It's also known as the listening socket. The server socket is passive and waits for clients to connect to it.

User Socket:
This is the socket used by the User program to initiate a connection to the server.
It's an active socket that initiates the communication by connecting to the server's listening socket.
*/

/*
After connecting with an IRC server, you typically do the following:
1. /nick <CHOSEN NICKNAME>														<-- TODO: What if the nickname is already registered?
2. /join <CHOSEN CHANNEL INSIDE THE SERVER>										<-- Works after having chosen a nickname.
3. <YOUR MESSAGE HERE>															<-- Without any specific command this will broadcast a message to everyone in the Channel.
3. /msg <SOMEONE'S NICKNAME> <YOUR MESSAGE HERE>								<-- Send a private message to another User.
*/

/*
[socket]
A combination of ip and port
e.g. 192.168.1.10:8080
socket will be used to listen for incoming connections from clients

[binding]
after creating a socket, you need to bind the socket to a specific ip socket_address and port
*/

/*
Classes overview:

[User]
Heeft info. over individuele clients, zoals sockets, IP, ports, nickname, password, etc.

[Channel]
Heeft info. over clients die in de channel zitten.
Clients kunnen worden toegevoegd/verwijderd via een member function van Channel.
TODO: Uitnodigen clients naar channels.
TODO: Verander de channel topic. Dit wordt gedaan door client die verbonden is met die channel.
TODO: Kick a client. Dit wordt gestart door een andere client.

[Command]
Deze class bevat alle server commando's (e.g. JOIN).
De class voegt ze ook samen in een dictionary.

[Server]
Initialiseert de server sockets, options, en koppelt de server aan een specifieke poort.
Low-level networking aspecten van de server.

Accepteert verbindingen van clients via accept().
Nieuwe clients worden opgeslagen in de Client objects.

Parsed en execute ook commands van de clients.
*/
