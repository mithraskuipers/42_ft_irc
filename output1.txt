# **************************************************************************** #
#                                                                              #
#                                                         ::::::::             #
#    output1.txt                                        :+:    :+:             #
#                                                      +:+                     #
#    By: mkuipers <mkuipers@student.codam.nl>         +#+                      #
#                                                    +#+                       #
#    Created: 2023/09/01 17:37:03 by mkuipers      #+#    #+#                  #
#    Updated: 2023/10/24 18:57:43 by mikuiper      ########   odam.nl          #
#                                                                              #
# **************************************************************************** #

#include "./../incs/includes.hpp"

void	color_red()
{
	printf("\033[0;31m");
}

void	color_orange()
{
	printf("\033[38;5;214m");
}

void	color_green()
{
	printf("\033[0;32m");
}

void	color_reset()
{
	printf("\033[0m");
}

void	clear_screen(void)
{
	write(1, "\x1b[2J", 4);
	write(1, "\x1b[H", 3);
}

void	splash()
{
	clear_screen();
	color_orange();
	printf("%s", SPLASH);
	color_reset();
}#include "./../incs/Server.hpp" // Include your Server.hpp file after the necessary system
#include "Server.hpp"

#include "Command.hpp"
#include <poll.h>

class Server;

Server::Server(int port, const std::string &password) : active_users(0), port(port), clients(), password(password), command(clients, *this), server_listening_socket(0), IP(), socket_address(), channels(), welcomeMessage("Welcome to the IRC server!") {}

std::string Server::getPass()
{
	return (this->password);
}

Server::~Server()
{
}

void Server::getHostIP()
{
	char host[256];
	gethostname(host, sizeof(host));

	struct hostent *host_entry;
	host_entry = gethostbyname(host);

	this->IP = inet_ntoa(*((struct in_addr *)host_entry->h_addr_list[0]));
}

void Server::initServer()
{
	int opt = 1;
	this->server_listening_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (this->server_listening_socket == 0)
	{
		throw(std::runtime_error("Failed to create socket"));
	}
	int setsockopt_ret = setsockopt(server_listening_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	if (setsockopt_ret == -1)
	{
		throw(std::runtime_error("Failed to set socket options"));
	}
	this->socket_address.sin_family = AF_INET;
	this->socket_address.sin_addr.s_addr = INADDR_ANY;
	this->socket_address.sin_port = htons(port);

	if (fcntl(server_listening_socket, F_SETFL, O_NONBLOCK) < -1)
	{
		throw std::runtime_error("Failed to set non-blocking mode");
	}

	if (bind(server_listening_socket, (struct sockaddr *)&this->socket_address, sizeof(this->socket_address)) < 0)
	{
		throw std::runtime_error("Failed to bind socket");
	}

	if (listen(server_listening_socket, QUEUE_SIZE) == -1)
	{
		throw std::runtime_error("Failed to start listening");
	}

	std::cout << "Listening on port: " << this->port << std::endl;
	std::cout << "The password you chose to use is: " << this->password << std::endl;
}

/*
generateRandomCode() for creating a random code for the "Guest" username.
*/
std::string Server::generateRandomCode()
{
	std::string randomCode;
	srand(time(0)); // Seed for random number generation based on current time

	// Generate a random code with a length of 4 digits
	for (int i = 0; i < 4; ++i)
	{
		char randomDigit = '0' + rand() % 10; // Generate a random digit
		randomCode.push_back(randomDigit);
	}

	return randomCode;
}

std::string Server::getClientIP(int clientSocket)
{
	for (const auto &user : clients)
	{
		if (user.getSocketDescriptor() == clientSocket)
		{
			return user.getIP();
		}
	}
	return ("Unknown IP"); // Return a default value if client IP is not found
}

int Server::getClientPort(int clientSocket)
{
	for (const auto &user : clients)
	{
		if (user.getSocketDescriptor() == clientSocket)
		{
			return user.getPort();
		}
	}
	return 0; // IP niet gevonden
}

std::string Server::usernameFromSocket(int clientSocket)
{
	for (const auto &user : clients)
	{
		if (user.getSocketDescriptor() == clientSocket)
		{
			return user.getNick();
		}
	}
	return ("UnknownUsername"); // Username niet gevonden
}

/*
isNicknameInUse() checks if a username has already been taken.
*/
int Server::isNicknameInUse(const std::string &nickname) const
{
	for (const auto &Client : clients)
	{
		if (Client.getNick() == nickname)
		{
			return (1);
		}
	}
	return (0);
}

/*
updateMaxSocketDescriptor() Finds maximum socket descriptor value among all connected clients.
Essential for select(), which is used to monitor multiple file descriptors for read readiness.
*/
int Server::updateMaxSocketDescriptor()
{
	int maxSocket = server_listening_socket;

	for (const auto &Client : clients)
	{
		if (Client.getSocketDescriptor() > maxSocket)
		{
			maxSocket = Client.getSocketDescriptor();
		}
	}
	return (maxSocket);
}




std::string Server::addClientSocket(int clientSocket)
{
    std::string welcomeMessage;
    const std::string defaultNickname = "Guest";
    std::string randomCode = generateRandomCode();
    std::string username = defaultNickname + randomCode;

    // Check if the client already exists in clients vector
    auto existingClient = std::find_if(clients.begin(), clients.end(), [clientSocket](const Client &user) {
        return user.getSocketDescriptor() == clientSocket;
    });

    if (existingClient != clients.end()) {
        // Client already exists, return the existing usernam
        return existingClient->getNick();
    }

    welcomeMessage = "IRC : To register please use commands PASS - NICK - USER(user, mode, unused, realname)\r\n";
    send(clientSocket, welcomeMessage.c_str(), welcomeMessage.size(), 0);

    while (isNicknameInUse(username))
    {
        randomCode = generateRandomCode();
        username = defaultNickname + randomCode;
    }

    clients.push_back(Client(clientSocket, username));

    welcomeMessage = ":" + std::string(SERVER_NAME) + " 001 " + username + " :Welcome to the IRC server, " + username + "!\r\n";
    send(clientSocket, welcomeMessage.c_str(), welcomeMessage.size(), 0);

    return username;
}




Client &Server::getClientByUsername(const std::string &username)
{
	for (auto &user : clients)
	{
		if (user.getNick() == username)
		{
			return (user);
		}
	}
	throw std::runtime_error("Client not found with the specified username");
}

void Server::sendMotdMessage(int client_socket, const std::string &username)
{
	std::string welcomeMessage = ":" + std::string(SERVER_NAME) + " 001 " + username + " :Welcome to the IRC server, " + username + "!\r\n";
	send(client_socket, welcomeMessage.c_str(), welcomeMessage.size(), 0);
	std::string motdMessage = ":" + std::string(SERVER_NAME) + " 375 " + username + " :- " + std::string(SERVER_NAME) + " Message of the Day -\r\n";
	send(client_socket, motdMessage.c_str(), motdMessage.size(), 0);

	std::string motdContent = ":" + std::string(SERVER_NAME) + " 372 " + username + " :- Welcome to our awesome IRC server! yugioh > magic!!! Enjoy your stay.\r\n";
	send(client_socket, motdContent.c_str(), motdContent.size(), 0);

	std::string endMotdMessage = ":" + std::string(SERVER_NAME) + " 376 " + username + " :End of /MOTD command.\r\n";
	send(client_socket, endMotdMessage.c_str(), endMotdMessage.size(), 0);
}


void Server::handleNewConnection(int client_socket)
{
    std::string username = addClientSocket(client_socket);
    std::cout << "New Client connected. Total clients: " << clients.size() << std::endl;
    sendMotdMessage(client_socket, username);
}


void Server::checkIfDataReceivedFromClient(int client_socket, std::vector<char> &buffer)
{
	// BUG FIX! Buffer resetting required for preventing server thinking new clients are constantly connecting
	buffer.clear();
	buffer.resize(2048);

	int bytes_received;
	
	// Receive data from client socket
	bytes_received = recv(client_socket, buffer.data(), buffer.size(), 0);

	if (bytes_received > 0)
	{
		// Process received data from the client
		std::string complete_command(buffer.data(), bytes_received);
		command.processRawClientData(complete_command, getClientByUsername(usernameFromSocket(client_socket)));
	}
	else
	{
		if (bytes_received == 0)
		{
			std::cout << "Client disconnected. Total clients: " << clients.size() - 1 << std::endl;
		}
		else
		{
			std::cerr << "Error: Failed to receive data from client: " << strerror(errno) << std::endl;
		}
		close(client_socket);
		auto it = std::remove_if(clients.begin(), clients.end(), [client_socket](const Client &user)
		{
			return user.getSocketDescriptor() == client_socket;
		});
		clients.erase(it, clients.end());
	}
}

void Server::startServer()
{
	std::vector<char> buffer(2048);
	int readySockets;

	while (true)
	{
		std::vector<pollfd> fds;
		pollfd serverSocket;
		serverSocket.fd = server_listening_socket;
		serverSocket.events = POLLIN;
		fds.push_back(serverSocket);

		for (const auto &Client : clients)
		{
			pollfd clientSocket;
			clientSocket.fd = Client.getSocketDescriptor();
			clientSocket.events = POLLIN;
			fds.push_back(clientSocket);
		}

		readySockets = poll(fds.data(), fds.size(), -1);

		if (readySockets == -1)
		{
			std::cerr << "Error: Failed to poll sockets: " << strerror(errno) << std::endl;
			break;
		}

		for (size_t i = 0; i < fds.size(); ++i)
		{
			int returned_events;
			returned_events = fds[i].revents;

			if ((returned_events & POLLIN))
			{
				// New client trying to connect.
				// Check whether current fd poll() is processing is server socket. If so, new incoming connection.
				if (fds[i].fd == server_listening_socket)
				{
					int client_socket = accept(server_listening_socket, NULL, NULL);

					if (client_socket != -1)
					{
						handleNewConnection(client_socket);
					}
					else
					{
						std::cerr << "Error: Failed to accept client connection: " << strerror(errno) << std::endl;
						continue;
					}
				}
				// Existing client
				else
				{
					checkIfDataReceivedFromClient(fds[i].fd, buffer);
				}
			}
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   Client.cpp                                         :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/17 22:22:03 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/18 23:01:05 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/Client.hpp"

#include <arpa/inet.h>	// For inet_ntop
#include <netinet/in.h> // For sockaddr_in
#include <sys/socket.h> // For getpeername
#include <unistd.h>		// For close function

// Constructor
// Other necessary includes

Client::Client(int socket_descriptor, const std::string &nick) : socket_descriptor(socket_descriptor), port(0), _nickname(nick), registered(false), ip("Unknown IP")
{
	// Constructor implementation
}

// Getter function for the socket descriptor
int Client::getSocketDescriptor() const
{
	return (socket_descriptor);
}

// Getter function for the buffer
std::string &Client::getBuff()
{
	return (buff);
}

void Client::setNick(const std::string &newNick)
{
	_nickname = newNick;
}

void Client::setRealName(const std::string &newRealName)
{
	_realname = newRealName;
}

void Client::send(const std::string &data)
{
	ssize_t bytesSent = write(socket_descriptor, data.c_str(), data.size());

	if (bytesSent < 0)
	{
		// Handle write error
	}
}

void Client::setRegistered(bool value)
{
	registered = value;
}

void Client::sendToClient(const std::string &message)
{
	::send(this->getSocketDescriptor(), message.c_str(), message.length(), 0);
}

// Getter function for the Client's IP address
std::string Client::getIP() const
{
	struct sockaddr_in addr;
	socklen_t addr_len = sizeof(addr);
	char ip[INET_ADDRSTRLEN];

	if (getpeername(socket_descriptor, (struct sockaddr *)&addr, &addr_len) == 0)
	{
		inet_ntop(AF_INET, &(addr.sin_addr), ip, INET_ADDRSTRLEN);
		return ip;
	}
	else
	{
		return ("Unknown IP");
	}
}

bool Client::getRegisteredStatus() const
{
	return registered;
}

std::string Client::getRealName() const
{
	return (_realname);
}

// Setter function to set the Client's IP address
void Client::setIP(const std::string &clientIP)
{
	ip = (clientIP);
}

// Getter function for the Client's port
int Client::getPort() const
{
	return (port);
}

// Setter function to set the Client's port
void Client::setPort(int clientPort)
{
	this->port = clientPort;
}

// Getter function for the Client's nickname
std::string Client::getNick() const
{
	return (_nickname);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   ft_split.cpp                                       :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/18 23:43:16 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/20 11:10:43 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "./../incs/includes.hpp"

std::vector<std::string> ft_split(const std::string& input, const std::string& delimiter)
{
	std::vector<std::string> tokens;
	std::size_t start = 0;
	std::size_t end = input.find(delimiter);

	while (end != std::string::npos)
	{
		tokens.push_back(input.substr(start, end - start));
		start = end + delimiter.length();
		end = input.find(delimiter, start);
	}

	tokens.push_back(input.substr(start));

	return tokens;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   main.cpp                                           :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/07/08 14:09:49 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/24 14:43:31 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */


/*


./brew install bitchx
./brew install ircii


irssi settings
/set rejoin_channels_on_reconnect off
/set channels_rejoin_unavailable off

*/

#include "./../incs/includes.hpp"

int err_msg_and_return(std::string s, int ret_val)
{
	std::cout << s << std::endl;
	return (ret_val);
}

int main(int argc, char **argv)
{
	int port;
	std::string password;
	splash();
	if (argc != 3)
		return (err_msg_and_return("Error: Usage: ./ircserv <port #> <password>", 1));
	port = atoi(argv[1]);
	password = argv[2];

	if (port < 1024 || port > 65535) // Ports below 1024 are reserved

		return (err_msg_and_return("Error: <port #> must be an int >= 1024 and =< 65535", 1));

	Server server(port, password);
	try
	{
		server.initServer();
		server.startServer();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: Exception caught - " << e.what() << std::endl;
	}
	return (0);
}
