/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   Command.cpp                                        :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/21 20:49:19 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/22 01:11:20 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

// Command.cpp

#include "Command.hpp"
#include "User.hpp"
#include "Channel.hpp"
#include <algorithm>
#include <unistd.h>
#include "./../incs/IRCServer.hpp"

class IRCServer; // Forward declaration of IRCServer class

Command::Command(std::vector<User>& clients, IRCServer& server) : clients(clients), ircServer(server) 
{
	// Constructor implementation
}

Command::~Command()
{
	// Destructor implementation
}

void Command::sendChannelList(User &user, const std::vector<Channel> &channels)
{
	if (channels.empty())
	{
		user.sendToClient("There are no channels in this server.\n");
	}
	else
	{
		std::string channelList = "Channel List:\n";
		for (const auto &channel : channels)
		{
			channelList += channel.getName() + " (" + std::to_string(channel.getUsersCount()) + " users)\n";
		}
		user.sendToClient(channelList);
	}
}

void Command::process(const std::string &input, User &client, std::vector<Channel> &channels)
{
	size_t spacePos = input.find(' ');
	std::string command = input.substr(0, spacePos); // Extract the command

	if (command == "/nick")
	{
	    std::string newNick;
	    if (spacePos != std::string::npos)
	    {
	        newNick = input.substr(spacePos + 1);
	        newNick = newNick.substr(newNick.find_first_not_of(' '));
	
	        if (!newNick.empty())
	        {
	            // Check if the nickname is already in use
	            bool nicknameInUse = false;
	            for (const auto &channel : channels)
	            {
	                for (const auto &user : channel.getUsers())
	                {
	                    if (user->getNick() == newNick)
	                    {
	                        nicknameInUse = true;
	                        break;
	                    }
	                }
	            }
	
	            if (!nicknameInUse)
	            {
	                if (client.getNick().empty())
	                {
	                    client.setNick(newNick);
	                    client.sendToClient(":" + newNick + " NICK " + newNick + "\r\n");
	                    std::cout << "Your nickname has been set to: " << newNick << std::endl;
	                }
	                else
	                {
	                    std::string oldNick = client.getNick();
	                    client.setNick(newNick);
	                    client.sendToClient(":" + oldNick + " NICK " + newNick + "\r\n");
	                    std::cout << "Your nickname has been changed from " << oldNick << " to " << newNick << std::endl;
	                }
	            }
	            else
	            {
	                client.sendToClient(":server 433 * " + newNick + " :Nickname is already in use\r\n");
	            }
	        }
	        else
	        {
	            client.sendToClient(":server 431 * :No nickname given\r\n");
	        }
	    }
	    else
	    {
	        client.sendToClient(":server 431 * :No nickname given\r\n");
	    }
	}

	else if (command == "/pass")
	{
	    std::string password = input.substr(spacePos + 1);
	
	    // Compare the provided password with the server password
	    if (password == serverPassword) {
	        client.setRegistered(true);
	        client.sendToClient(":server 001 " + client.getNick() + " :Welcome to the IRC server, " + client.getNick() + "!\r\n");
	        std::cout << "User " << client.getNick() << " has successfully registered." << std::endl;
	    } else {
	        client.sendToClient(":server 464 " + client.getNick() + " :Password incorrect\r\n");
	        std::cout << "User " << client.getNick() << " failed to register. Incorrect password." << std::endl;
	    }
	}
	
	else if (command == "/quit")
	{
	    std::string quitMessage = input.substr(spacePos + 1);
	
	    // Broadcast quit message to all channels the user is in
    	// Inside the function, you can now use the 'clients' vector
		auto iterator = std::find_if(clients.begin(), clients.end(), [&client](const User &user) {
		    return user.getSocketDescriptor() == client.getSocketDescriptor();
		});
		
		if (iterator != clients.end()) {
		    clients.erase(iterator);
		}
		
	
	    // Close the client socket and remove the user from the server
	    close(client.getSocketDescriptor());
	
	    // Find the client in the clients vector and remove it
	    auto it = std::find_if(clients.begin(), clients.end(), [&client](const User &user)
	                           { return user.getSocketDescriptor() == client.getSocketDescriptor(); });
	    if (it != clients.end())
	    {
	        clients.erase(it);
	    }
	
	    std::cout << "User " << client.getNick() << " has quit the server." << std::endl;
	}
	
	else if (command == "/user")
	{
		std::string parameters = input.substr(spacePos + 1);
		size_t secondSpacePos = parameters.find(' ');

		if (secondSpacePos != std::string::npos)
		{
			std::string username = parameters.substr(0, secondSpacePos);
			std::string realname = parameters.substr(secondSpacePos + 1);

			// Set the user's username and real name
			client.setNick(username);
			client.setRealName(realname);

			// Respond with a welcome message or MOTD (Message of the Day)
			client.sendToClient(":server 001 " + client.getNick() + " :Welcome to the IRC server, " + client.getNick() + "!\r\n");

			// You can add more welcome messages or instructions here if needed

			std::cout << "User " << client.getNick() << " registered with username: " << username << " and real name: " << realname << std::endl;
		}
		else
		{
			client.sendToClient(":server 461 " + client.getNick() + " USER :Not enough parameters\r\n");
			// You can send an error response indicating incorrect usage of the USER command
		}
	}
		

	else if (command == "/list")
	{
		std::cout << "Executing /list for " << client.getNick() << std::endl;
		sendChannelList(client, channels);
		return;
	}
	else if (command == "/create")
	{
		std::string channelName = input.substr(spacePos + 1);
		bool channelExists = false;
		for (const auto &channel : channels)
		{
			if (channel.getName() == channelName)
			{
				channelExists = true;
				std::cout << "Channel already exists with the name: " << channelName << std::endl;
				break;
			}
		}
		if (!channelExists)
		{
			Channel newChannel(channelName);
			newChannel.addUser(&client);
			channels.push_back(newChannel);
			std::cout << "Created new channel named: " << channelName << std::endl;

			// Send IRC protocol messages for channel creation
			std::string joinMessage = ":" + client.getNick() + " JOIN :" + channelName + "\r\n";
			std::string topicMessage = ":" + client.getNick() + " TOPIC " + channelName + " :Welcome to " + channelName + " channel!\r\n";
			std::string endOfNamesMessage = ":server 366 " + client.getNick() + " " + channelName + " :End of NAMES list\r\n";

			client.sendToClient("Channel created: " + channelName + "\n");

			// Send IRC messages to all users in the new channel
			for (auto &user : channels.back().getUsers())
			{
				user->sendToClient(joinMessage);
				user->sendToClient(topicMessage);
				user->sendToClient(endOfNamesMessage);
			}
		}
		else
		{
			client.sendToClient("Channel already exists with the name: " + channelName + "\n");
		}
	}

	else if (command == "/join")
	{
		std::string channelName = input.substr(spacePos + 1);
		bool alreadyInChannel = false;
		bool channelFound = false;

		// Check if the client is already in a channel
		for (const auto &channel : channels)
		{
			if (channel.isUserInChannel(&client))
			{
				alreadyInChannel = true;
				break;
			}
		}

		if (!alreadyInChannel)
		{
			for (auto &channel : channels)
			{
				if (channel.getName() == channelName)
				{
					// Add the user to the channel
					channel.addUser(&client);
					client.sendToClient("Joined channel: " + channelName + "\n");

					// Send JOIN message back to the client indicating successful channel join
					std::string joinMessage = ":" + client.getNick() + " JOIN " + channelName + "\n";
					client.sendToClient(joinMessage);

					// Send the channel topic and user list (if available) here, if needed

					channelFound = true;
					break;
				}
			}

			if (!channelFound)
			{
				client.sendToClient("Channel not found: " + channelName + "\n");
			}
		}
		else
		{
			client.sendToClient("You are already in the channel " + channelName + ".\n");
		}
	}

	else if (command == "/leave")
	{
		std::string channelName = input.substr(spacePos + 1);
		auto it = std::find_if(channels.begin(), channels.end(), [&channelName](const Channel &channel)
							   { return channel.getName() == channelName; });

		if (it != channels.end())
		{
			if (it->isUserInChannel(&client))
			{
				it->removeUser(&client);
				std::cout << "You left channel: " << channelName << std::endl;
			}
			else
			{
				std::cout << "You are not in channel: " << channelName << std::endl;
			}
		}
		else
		{
			std::cout << "Channel not found: " << channelName << std::endl;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   Channel.cpp                                        :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/10/21 20:49:24 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/21 23:22:42 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#include "Channel.hpp"
#include "User.hpp"
#include "includes.hpp"

Channel::Channel() : topic(""), topicAuthor("") {}

Channel::~Channel() {}

Channel::Channel(const std::string &name) : channelName(name) {}

void Channel::addUser(User *user)
{
	users.push_back(user);
}


void Channel::broadcastMessage(const std::string& message)
{
    for (auto& user : users)
    {
        user->sendToClient(message);
    }
}


int Channel::getUsersCount() const
{
	return users.size();
}

bool Channel::isEmpty() const
{
	return users.empty();
}

std::string Channel::getName() const
{
	return channelName;
}

#include <string> // Include the necessary header for std::string

// Assuming USER_IDENTIFIER is a std::string
std::string USER_IDENTIFIER = "User:";

// Inside your setTopic function
void Channel::setTopic(const std::string &topic, User *user)
{
	// Assuming getNick() returns a C-style string
	topicAuthor = USER_IDENTIFIER + " " + std::string(user->getNick());
	(void)topic;
	// Rest of your code
}

std::string Channel::getTopic() const
{
	return topic;
}

std::string Channel::getTopicAuthor() const
{
	return topicAuthor;
}

bool Channel::isOperator(User *user) const
{
	auto it = std::find(operators.begin(), operators.end(), user);
	return it != operators.end();
}

void Channel::addOperator(User *user)
{
	operators.push_back(user);
}

void Channel::removeOperator(User *user)
{
	auto it = std::find(operators.begin(), operators.end(), user);
	if (it != operators.end())
	{
		operators.erase(it);
	}
}


void Channel::listUsers() const {
    std::cout << "Users currently in the channel " << channelName << ":\n";
    for (const auto& user : users) {
        std::cout << "- " << user->getNick() << "\n";
    }
}


bool Channel::isUserInChannel(const User* user) const {
	    std::cout << "Checking if user is in the channel..." << std::endl;
		listUsers();
        for (const auto& u : users) {
            if (u == user) {
                return true;
            }
        }
        return false;
}

void Channel::removeUser(User *user)
{
	    std::cout << "Removing user from the channel..." << std::endl;
		listUsers();
    auto it = std::find(users.begin(), users.end(), user);
    if (it != users.end())
    {
        users.erase(it);
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   IRCServer.hpp                                      :+:    :+:            */
/*                                                     +:+                    */
/*   By: mkuipers <mkuipers@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/09/01 17:56:34 by mkuipers      #+#    #+#                 */
/*   Updated: 2023/10/22 01:04:15 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#ifndef IRCSERVER_HPP
#define IRCSERVER_HPP

#include "includes.hpp"
#include <netinet/in.h> // struct sockaddr_in
#include <list>
#include "Command.hpp"
#include "Channel.hpp" // Include the Channel.hpp header file

class User;

class IRCServer
{
public:
	IRCServer();
	IRCServer(int port, const std::string &password);
	~IRCServer();
	void initServer(); // initialize server
	void start();	   // start server
	void getHostIP();  // get host ip
	std::string getIP() const;
	int updateMaxSocketDescriptor();
	int getPort() const;
	std::string addClientSocket(int clientSocket); // Update the declaration
	std::string generateRandomCode();
	bool isNicknameInUse(const std::string &nickname) const;

private:
    std::vector<User> clients;  // Add a vector to store clients
	unsigned int active_users;
	int port;
	int server_listening_socket;
	std::string password;
	std::string IP;
	struct sockaddr_in socket_address;
	Command command;
	std::vector<Channel> channels; // Declare the channels vector here
	std::string welcomeMessage; // Add this member variable
};

#endif
#ifndef COMMAND_HPP
#define COMMAND_HPP

#include <iostream>
#include <string>
#include <vector>
#include "../incs/IRCServer.hpp"
#include "IRCServer.hpp"



class User;
class Channel;

class Command
{
private:
    std::vector<User> &clients; // Add a vector to store clients

public:
    ~Command();
    Command(std::vector<User> &clients, IRCServer &server);
    void process(const std::string &input, User &user, std::vector<Channel> &channels);
    void sendChannelList(User &user, const std::vector<Channel> &channels);
    void sendNumericReply(User &user, int numericCode, const std::string &message);
};

#endif // COMMAND_HPP
#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <vector>
#include <string>

class User;

class Channel
{
public:
	Channel();
	~Channel();
	Channel(const std::string &name);
	void addUser(User *user);
	void removeUser(User *user);
	bool isEmpty() const;
	void listUsers() const;
	std::string getName() const; // Declaration of the getName() member function

	void setTopic(const std::string &topic, User *user);
	std::string getTopic() const;
	std::string getTopicAuthor() const;

	bool isOperator(User *user) const;
	void addOperator(User *user);
	void removeOperator(User *user);
	int getUsersCount() const;
	bool isUserInChannel(const User* user) const;
	const std::vector<User*>& getUsers() const {return users;}
	void broadcastMessage(const std::string& message);

private:
	std::vector<User *> users;
	std::string channelName; // Variable to store the channel name
	std::string topic;
	std::string topicAuthor;
	std::vector<User *> operators;
};

#endif // CHANNEL_HPP
#ifndef USER_HPP
#define USER_HPP

#include <string>

class User
{
private:
	int socket_descriptor;
	int port;
	std::string _nickname;
	std::string buff;
	bool registered;
	std::string ip;
	std::string _realname;

public:
	void sendToClient(const std::string &data);

	User(int socket_descriptor, const std::string &nick = "");
	int getSocketDescriptor() const;
	std::string &getBuff();
	void setNick(const std::string &newNick);
	void setRealName(const std::string &newRealName);
	void send(const std::string &data);
	std::string getIP() const;
	void setIP(const std::string &clientIP);
	int getPort() const;
	void setPort(int clientPort);
	std::string getNick() const;
	bool getRegisteredStatus() const;
	void setRegistered(bool value) {
        registered = value;
    }
};

#endif // USER_HPP
/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   splash.hpp                                         :+:    :+:            */
/*                                                     +:+                    */
/*   By: mkuipers <mkuipers@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/09/01 17:56:46 by mkuipers      #+#    #+#                 */
/*   Updated: 2023/09/01 18:04:40 by mkuipers      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#ifndef SPLASH_H
# define SPLASH_H

void splash();
void color_red();
void color_orange();
void color_green();
void color_reset();
void clear_screen();

#define SPLASH "\
⠀⠀⠀⠀⠀⠀⠀⢀⣀⡤⠴⠶⠶⠒⠲⠦⢤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n\
⠀⠀⠀⠀⢀⡠⠞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠲⠤⣄⡀⠀⠀⠀⠀\n\
⠀⠀⣀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⡿⠀⠀⠀⠀\n\
⠀⢾⣅⡀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⢀⡦⠤⠄⠀⠀⢻⡀⠀⠀⠀⠀\n\
⠀⠈⢹⡏⠀⠀⠐⠋⠉⠁⠀⠻⢿⠟⠁⠀⠀⢤⠀⠀⠠⠤⢷⣤⣤⢤⡄\n\
⠀⠀⣼⡤⠤⠀⠀⠘⣆⡀⠀⣀⡼⠦⣄⣀⡤⠊⠀⠀⠀⠤⣼⠟⠀⠀⢹⡂\n\
⠀⠊⣿⡠⠆⠀⠀⠀⠈⠉⠉⠙⠤⠤⠋⠀⠀⠀⠀⠀⠀⡰⠋⠀⠀⠀⡼⠁\n\
⠀⢀⡾⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠜⠁⠀⠀⠀⣸⠁⠀\n\
⠀⠀⠀⡼⠙⠢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀\n\
⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠃⠀⠀⠀\n\
⠀⡼⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀\n\
⣾⠁⠀⢀⣠⡴⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀\n\
⠈⠛⠻⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀\n\
"

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        ::::::::            */
/*   includes.hpp                                       :+:    :+:            */
/*                                                     +:+                    */
/*   By: mikuiper <mikuiper@student.codam.nl>         +#+                     */
/*                                                   +#+                      */
/*   Created: 2023/07/08 14:12:24 by mikuiper      #+#    #+#                 */
/*   Updated: 2023/10/21 20:31:41 by mikuiper      ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */

#ifndef INCLUDES_HPP

#include <iostream>
#include <cstdlib> // atoi
#include "IRCServer.hpp"
#include <cstdio> // printf
#include "splash.hpp"
#include <unistd.h>
#include <algorithm>
#include "User.hpp"
#include "Command.hpp"
#include "Channel.hpp"
#include <cstring> // string.h
#include <algorithm>

#define QUEUE_SIZE 3
#define TRUE 1
#define FALSE 0
#define MAX_CLIENTS 10
#define ESC_KEY 27

#define SERVER_NAME "bananenrepubliek"

#endif